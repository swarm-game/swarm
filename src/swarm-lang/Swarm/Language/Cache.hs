{-# LANGUAGE ViewPatterns #-}

-- |
-- SPDX-License-Identifier: BSD-3-Clause
--
-- Caches for fully loaded + typechecked modules and their resulting
-- environments, for fast importing + evaluation of modules that have
-- not changed.
module Swarm.Language.Cache (
  moduleCache,
  envCache,
  moduleNeedsLoad,
)
where

import Control.Algebra (Has)
import Control.Effect.Lift (Lift, sendIO)
import Swarm.Language.Module (Module (moduleTimestamp))
import Swarm.Language.Syntax (Phase (Elaborated))
import Swarm.Language.Syntax.Import hiding (ImportPhase (..))
import Swarm.Language.Syntax.Import qualified as Import
import Swarm.Language.Value (Env)
import Swarm.Util.GlobalCache (GlobalCache)
import Swarm.Util.GlobalCache qualified as GC
import System.Directory (getModificationTime)
import System.IO.Unsafe (unsafePerformIO)

-- | A global cache for fully parsed, typechecked, + elaborated
--   modules, to avoid reloading the same module from disk repeatedly.
moduleCache :: GlobalCache (ImportLoc Import.Resolved) (Module Elaborated)
moduleCache = unsafePerformIO GC.newGlobalCache
{-# NOINLINE moduleCache #-}

-- | A global cache for the environment generated by evaluated
--   modules, to avoid re-executing the same module repeatedly.
envCache :: GlobalCache (ImportLoc Import.Resolved) Env
envCache = unsafePerformIO GC.newGlobalCache
{-# NOINLINE envCache #-}

-- | Check whether a module needs to be loaded, /i.e./ either it is
--   not in the cache, or the cache entry is outdated.
moduleNeedsLoad :: (Has (Lift IO) sig m) => ImportLoc Import.Resolved -> m Bool
moduleNeedsLoad loc = do
  cached <- sendIO $ GC.lookupCached moduleCache loc
  maybe (pure True) (isOutdated loc) cached

-- | Check whether a module is outdated and needs to be reloaded +
--   rechecked.  For local files, this is determined by comparing the
--   file's modification time with the module's timestamp.
--
--   Modules loaded from URLs, on the other hand, are never considered
--   outdated.  There is no consistent way to get a "modification
--   time" for a remote file; in any case, typically, we expect
--   modules loaded from URLs to change much less frequently than
--   those loaded from local files.  If you want to pick up a change
--   to a module imported from a URL, you can restart the entire app
--   to clear the cache.
isOutdated :: (Has (Lift IO) sig m) => ImportLoc Import.Resolved -> Module phase -> m Bool
isOutdated cloc (moduleTimestamp -> mt) = case locToPath cloc of
  -- URLs are never outdated
  URL {} -> pure False
  -- For local files, get the modification time and compare to
  -- stored timestamp.
  LocalPath f ->
    maybe
      (pure True) -- Modules without a timestamp are always outdated
      (\t -> (t <) <$> sendIO (getModificationTime f))
      mt
